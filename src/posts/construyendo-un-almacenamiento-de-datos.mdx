---
title: Construyendo un Event Storage
date: 2019-02-01
author: arthur
tags: [eventos, dise√±o, arquitectura]
image: https://cqrs.files.wordpress.com/2010/11/image26.png?w=525&h=110&zoom=2
isPublic: false
---

En ["Eventos como mecanismo de almacenamiento"][1], se analiz√≥ desde un punto de vista conceptual, como a partir de una serie de eventos se pod√≠a reconstruir el estado de una aplicaci√≥n. Este cap√≠tulo se centra en la implementaci√≥n de un Event Storage (almac√©n de datos) y algunos de los problemas que surgen al desarrollarlo.

Notas:

- La implementaci√≥n discutida en este cap√≠tulo no pretende ser un Event Storage con la calidad suficiente para ser usada en producci√≥n, sino para servir como punto de discusi√≥n del c√≥mo construir un Event Storage. Esta implementaci√≥n, aunque no tiene un alto rendimiento, puede satisfacer las necesidades de un gran porcentaje de aplicaciones que se construyen hoy en d√≠a.

- Para esta implementaci√≥n explicativa, construiremos el Event Storage en una tecnolog√≠a existente, un RDBMS. Esto alivia muchos de los problemas (t√©cnicos) que de otro modo surgir√≠an y que est√°n fuera del alcance de esta discusi√≥n, esto es, problemas como los modelos de commit de transacciones o la localidad de datos para el rendimiento de lectura.

## Estructura

Un Event Storage b√°sico se puede representar en una base de datos relacional utilizando solo dos tablas.

| Nombre de columna | Tipo de columna |
| ----------------- | --------------- |
| AggregateId       | Guid            |
| Data              | Blob            |
| Version           | Int             |

Figura 1. Estructura de la tabla Eventos

La primera tabla representa realmente el registro de eventos (Event Log). Habr√° una registro o entrada por cada evento en esta tabla. El evento en s√≠ se almacena en la columna [Data]. El evento se almacena utilizando alguna forma de serializaci√≥n; durante el resto de esta discusi√≥n, se asumir√° que el mecanismo usa alg√∫n tipo de serializaci√≥n, aunque el uso del patr√≥n [Memento](https://en.wikipedia.org/wiki/Memento_pattern) puede traer muchas ventajas.

La tabla que se muestra tiene la m√≠nima cantidad de informaci√≥n posible, sin embargo, la mayor√≠a de organizaciones agregan otras columnas, como el tiempo en que se realiz√≥ el cambio o alguna informaci√≥n sobre el contexto. Ejemplos de informaci√≥n del contexto pueden ser el usuario que inici√≥ el cambio, su direcci√≥n IP o el nivel de permiso que tenia cuando sucedio el cambio.

Un n√∫mero de versi√≥n tambi√©n se almacena junto a cada evento. En la mayor√≠a de los casos, se puede considerarla como un n√∫mero entero y incremental. El n√∫mero de versi√≥n es √∫nico y secuencial **solamente dentro del contexto de un Agregado** dado. Esto se debe a que la Ra√≠z Agregada (Aggregate Root) define los l√≠mites de consistencia (boundaries).

La columna [AggregateId] es una clave externa que se debe indexar; adem√°s apunta a la siguiente tabla, que es la tabla de Agregados.

| Nombre de columna | Tipo de columna |
| ----------------- | --------------- |
| AggregateId       | Guid            |
| Type              | Varchar         |
| Version           | Int             |

Figura 2. Estructura de la tabla Agregados

_Comentario del autor: He dado varias vueltas üòµ sobre si llamar a este concepto "Agregado" (Aggregate) en lugar de otro nombre como "Proveedor de eventos" (Event Provider), ya que realmente Agreggate es un concepto del dominio, sin embargo un Event Storage puede funcionar sin un dominio._

La tabla de Agregados representa los Agregados actuales en el sistema, cada agregado debe tener una registro en esta tabla. Opcionalmente, junto con el identificador podremos tener el n√∫mero de versi√≥n actual desnormalizada para cada Agregado, principalmente por motivos de optimizaci√≥n, ya que podr√≠a derivarse de la tabla de Eventos, pero es mucho m√°s r√°pido consultar la desnormalizaci√≥n en vez de consultarlo directamente la tabla de Eventos. Adem√°s, este valor tambi√©n se utiliza en la verificaci√≥n de concurrencia optimista ((optimistic concurrency)[https://www.martinfowler.com/eaaCatalog/optimisticOfflineLock.html]).

Tambi√©n se incluye una columna [Tipo] para este ejemplo, este ser√≠a el nombre completo del tipo de agregado que se almacena (por ejemplo un Agregado podr√≠a ser los Pedidos 120 y 203, mientras que el Tipo de ellos vendr√≠a ser Pedido). Esto puede ser √∫til para varios prop√≥sitos, uno de los cuales es en el debug, sin embargo, no es necesario para la creaci√≥n de un Event Storage b√°sico.

## Operaciones

Los Event Storage son mucho m√°s simples que la mayor√≠a de los mecanismos de almacenamiento de datos, ya que no admiten consultas de prop√≥sito general. Un Event Storage, en su nivel m√°s simple, tiene solo dos operaciones. Al tener solo dos operaciones hace que un Event Storage sea m√°s simple que la mayor√≠a de los mecanismos de almacenamiento de datos, as√≠ como m√°s f√°cil de optimizar.

La primera operaci√≥n es obtener todos los eventos de un Agregado. Es extremadamente importante que los eventos se ordenen en el mismo orden en que se escribieron, el n√∫mero de versi√≥n se puede usar para este prop√≥sito. Todo esto se puede hacer simplemente usando un RDBMS.

```sql
SELECT * FROM events WHERE AggregateID = '' ORDER BY version
```

Esta es la √∫nica consulta que siempre se ejecutar√° al Event Storage. Otra posible consulta, que puede ser √∫til, es limitar el conjunto de resultados por una fecha para ver el estado de un Agregado en un momento determinado, pero generalmente un sistema de producci√≥n no deber√≠a hacer eso.

La otra operaci√≥n que debe tener un Event Storage es la escritura de un conjunto de eventos en Agregado. Esto se puede hacer bien en c√≥digo o en un procedimiento almacenado. Es preferido usar un procedimiento almacenado o un SQL generado din√°micamente con sentencias `if/for`, ya que sino el proceso de inserci√≥n tendr√° hacer varios viajes de ida y vuelta üõ´. El pseudoc√≥digo para el proceso de inserci√≥n se puede ver en el Listado 1.

```sql
Begin
  version = SELECT version from aggregates where AggregateID = ''
  if version is null
    insert into aggregates
    version = 0
  end
  if expectedversion != version -- optimistic concurrency test
    raise concurrency problem
  end

  foreach event
    insert event with incremented version number
  end
  update aggregate with last version number
End Transaction
```

Listado 1. Operaci√≥n de escritura en un Event Storage

La operaci√≥n de escritura tambi√©n es relativamente simple, aunque hay algunas sutilezas se pueden ver. Primero se verifica si existe un agregado con el identificador √∫nico, si no existe, lo crea tomando la versi√≥n actual como cero. Luego, se realiza una prueba de concurrencia optimista en los datos que ingresan, si la versi√≥n ingresada no coincide con la versi√≥n actual, se generar√° una excepci√≥n de concurrencia. Si son iguales, recorrer√° los eventos a guardar y los insertar√° en la tabla de eventos, incrementando el n√∫mero de versi√≥n en uno para cada evento. Finalmente, actualizar√° la tabla de Agregados al nuevo n√∫mero de versi√≥n actual. Es importante tener en cuenta que estas operaciones est√°n dentro de una transacci√≥n, ello es necesario para asegurar que la concurrencia optimista, entre otras cosas, funcione en un entorno distribuido.

El contrato para un Event Storage en c√≥digo se puede definir con la siguiente interfaz.

```csharp
public interface EventStore {
    void SaveChanges(GUid AggregateId, int OriginatingVersion, IEnumerable<Event> events);
    IEnumerable<Event> GetEventsFor(Guid AggregateId);
}
```

Listado 2. Interface para un Event Store

Aunque no es un ejercicio trivial crear un Event Storage de calidad, los conceptos generales detr√°s de un Event Storage son relativamente f√°ciles. Probablemente en el futuro habr√° muchos sistemas de Event Storage disponibles bien como productos o como proyectos de c√≥digo abierto (nota, el post original fue escrito en el 2010). Sin embargo, hay una optimizaci√≥n muy importante que se discuti√≥ en ["Eventos como un mecanismo de almacenamiento"][1] que realmente deber√≠a existir en la mayor√≠a de los sistemas y ese es el concepto de una "Rolling Snapshots".

## Rolling Snapshots

Las "instant√°neas progresivas" (Rolling Snapshots o simplemente Snapshots) son una heur√≠stica para evitar la necesidad de cargar todos los eventos de un Agregado. Son una desnormalizaci√≥n del Agregado en un momento dado en el tiempo. Un cambio en la l√≥gica de consulta y una tabla adicional son todo lo que se necesita para agregar esta heur√≠stica al Event Storage. Puede encontrar m√°s informaci√≥n sobre Rolling Snapshots a nivel conceptual en el cap√≠tulo ["Eventos como mecanismo de almacenamiento"][1].

| Nombre de columna | Tipo de columna |
| ----------------- | --------------- |
| AggregateId       | Guid            |
| SerializedData    | Blob            |
| Version           | Int             |

Figura 3. Estructura de la tabla Snapshots

La tabla de instant√°neas es relativamente b√°sica. Son los datos primarios en el blob que contiene la versi√≥n serializada del agregado en un momento dado en el tiempo. Los datos serializados podr√≠an estar en cualquiera de una gran cantidad de esquemas posibles, binarios, XML, texto sin formato, etc. La decisi√≥n sobre c√≥mo serializar las instant√°neas realmente depende del sistema que se est√° construyendo. Se incluye un n√∫mero de versi√≥n con la instant√°nea, que representa qu√© versi√≥n del agregado representa la instant√°nea.

Para poder crear instant√°neas se debe introducir un proceso que maneje la tarea de crear las instant√°neas. Este proceso puede vivir fuera del servidor de aplicaciones como un proceso en segundo plano. Puede haber un solo proceso en ejecuci√≥n o muchos dependiendo de las necesidades debido al rendimiento. Todas las instant√°neas suceden de forma as√≠ncrona. La Figura 4 muestra una arquitectura conceptual con un proceso [SnapShotter] introducido.

![Introducci√≥n a un SnapShotter](https://cqrs.files.wordpress.com/2010/11/image28.png?w=498&h=530&zoom=2)

Figura 4. Introducci√≥n a un SnapShotter

El [SnapShotter] se encuentra detr√°s del Event Storage y consulta peri√≥dicamente los agregados que necesitan tomarse una instant√°nea porque han pasado el n√∫mero permitido de eventos. Esta consulta se puede hacer con bastante facilidad en el simple Event Storage discutido al unir la tabla de agregados a la tabla de instant√°neas en el identificador de agregados. La diferencia se calcula restando la √∫ltima versi√≥n de instant√°nea de la versi√≥n actual con una cl√°usula where que solo devolvi√≥ los agregados con una diferencia mayor que alg√∫n n√∫mero. Esta consulta devolver√° todos los agregados que se crear√° una instant√°nea. El snapshotter luego iterar√≠a a trav√©s de esta lista de agregados para crear los snapshots (si al usar m√∫ltiples snapshotters, el patr√≥n de consumidor competidor funciona bien aqu√≠).

El proceso de crear una instant√°nea implica que el dominio cargue la versi√≥n actual del Agregado y luego tomar una instant√°nea de la misma. La creaci√≥n de la instant√°nea se puede hacer de muchas maneras. Una vez que se ha tomado la instant√°nea, se guarda de nuevo en la tabla de instant√°neas para que las consultas tengan la instant√°nea disponible.

Muchos usan el paquete de serializaci√≥n predeterminado disponible con su plataforma con buenos resultados, aunque el patr√≥n Memento es bastante √∫til cuando se trata de instant√°neas. El patr√≥n Memento (o serializaci√≥n personalizada) a√≠sla mejor el dominio a lo largo del tiempo a medida que cambia la estructura de los objetos del dominio. El serializador predeterminado tiene problemas de versi√≥n cuando se lanza la nueva estructura (las instant√°neas existentes deben eliminarse y recrearse o actualizarse para que coincida con el nuevo esquema). El uso del patr√≥n Memento permite la creaci√≥n de versiones separadas del esquema de instant√°neas desde el objeto de dominio en s√≠.

En ‚ÄúEventos como mecanismo de almacenamiento‚Äù, se mostr√≥ un mecanismo diferente y m√°s simple para el almacenamiento de instant√°neas. Ese sistema ten√≠a las instant√°neas en l√≠nea en el Registro de eventos, este otro mecanismo, aunque conceptualmente m√°s simple tiene algunos problemas que pueden surgir en un sistema de producci√≥n. Los problemas giran en torno a la necesidad de ordenar la instant√°nea dentro del registro de eventos.

Tenga en cuenta que el Snapshotter se ha dado cuenta de que una ra√≠z agregada debe tener una instant√°nea tomada. Carga el Agregado y toma la instant√°nea. Desafortunadamente, mientras hac√≠a esto, uno de los Servidores de aplicaciones realiz√≥ un cambio en el mismo Agregado. Como la instant√°nea depende de la posici√≥n en el Registro de eventos, recibir√° un error de concurrencia optimista. La respuesta f√°cil ser√≠a simplemente repetir el proceso, pero ¬øqu√© pasar√≠a si fallara nuevamente? El snapshotter en un agregado muy ocupado podr√≠a terminar en una situaci√≥n en la que tendr√≠a una probabilidad muy baja de escribir la instant√°nea con √©xito.

Al separar las instant√°neas en su propia tabla y asociarlas a una versi√≥n del agregado, se soluciona este problema. No es necesario ordenar las instant√°neas, la instant√°nea ni siquiera necesita estar en la √∫ltima versi√≥n, la instant√°nea que se toma es v√°lida en la versi√≥n que se tom√≥.

Las instant√°neas son una heur√≠stica que mejorar√° dr√°sticamente el rendimiento de muchos sistemas, aunque no todos los sistemas necesitan instant√°neas. En general, se recomienda manejar el desarrollo sin instant√°neas, ya que siempre se puede introducir m√°s tarde como una mejora de rendimiento simple para el sistema.

Event Storage como una cola
Se ha discutido previamente que los eventos que salen de un dominio tambi√©n son un [Modelo de Integraci√≥n]. Muy a menudo, estos eventos no solo se guardan sino que tambi√©n se publican en la cola donde se env√≠an de forma as√≠ncrona a los oyentes, ya sea dentro del mismo sistema (el modelo de informe es un buen ejemplo) o a otras aplicaciones. Un problema que existe con muchos sistemas que publican eventos es que requieren una confirmaci√≥n de dos fases entre cualquier almacenamiento que est√©n utilizando (Relacional o de otro tipo) y la publicaci√≥n de sus eventos en la cola.

La raz√≥n por la que se necesita la confirmaci√≥n de dos fases es que puede ocurrir una cat√°strofe durante el peque√±o per√≠odo de tiempo entre la confirmaci√≥n de la escritura en el almacenamiento de datos y la confirmaci√≥n de la escritura en la cola. Si ocurriera una falla durante este per√≠odo, el mensaje no se publicar√≠a en la cola (o si la otra direcci√≥n puede publicarse pero el cambio no se puede guardar). Si cualquiera de los dos casos ocurriera, los oyentes de los eventos no estar√≠an sincronizados con el productor.

La confirmaci√≥n en dos fases puede ser costosa, pero para los sistemas de baja latencia hay un problema mayor cuando se trata de esta situaci√≥n. En general, la propia cola es persistente, por lo que el evento se escribe dos veces en el disco en la confirmaci√≥n de dos fases, una vez en el Event Storage y una vez en la cola persistente. Dado que para la mayor√≠a de los sistemas que tienen escrituras duales no es tan importante, pero si tiene requisitos de baja latencia, puede convertirse en una operaci√≥n bastante costosa, ya que tambi√©n forzar√° las b√∫squedas en el disco. La Figura 5 ilustra la confirmaci√≥n en dos fases entre el almacenamiento de datos y una cola de publicaci√≥n.

![Commit de 2 fases con Cola](https://cqrs.files.wordpress.com/2010/11/image29.png?w=530&h=346&zoom=2)

Figura 5. Commit de 2 fases con Cola

Algunos intentan solucionar este problema escribiendo solo en una cola y luego, al otro lado de la cola, actualizar el almacenamiento de datos con los cambios representados por los eventos; sin embargo, esto tiene algunos problemas. El mayor problema es que no todos los eventos podr√°n escribirse en el almacenamiento, se ha introducido una consistencia final y es posible que ocurra un problema de concurrencia optimista en la escritura de los eventos. Tratar este problema en un sistema de producci√≥n no es trivial.

Muchas organizaciones hacen lo contrario, usan el Event Storage como una cola. Agregar un n√∫mero de secuencia a la tabla de Eventos discutida previamente permite el uso del Event Storage como una cola. La Figura 5 ilustra el cambio en el esquema de la tabla de Eventos.

| Nombre de columna | Tipo de columna |
| ----------------- | --------------- |
| AggregateId       | Guid            |
| Data              | Blob            |
| SequenceNumber    | Long            |
| Version           | Int             |

Figura 6. Tabla de Eventos como una Cola

La base de datos asegurar√≠a que los valores del n√∫mero de secuencia sean √∫nicos e incrementales, esto se puede hacer f√°cilmente usando un tipo de incremento autom√°tico. Debido a que los valores son √∫nicos y el incremento de un proceso secundario puede perseguir la tabla de Eventos, publicando los eventos en otra cola. El proceso de b√∫squeda simplemente tendr√≠a que almacenar el valor del n√∫mero de secuencia del √∫ltimo evento que hab√≠a procesado, incluso podr√≠a actualizar este valor con un compromiso de dos fases que lleva la actualizaci√≥n y la publicaci√≥n a la cola en la misma transacci√≥n. Este proceso se puede ver en la Figura 7.

![Event Storage como Cola](https://cqrs.files.wordpress.com/2010/11/image31.png?w=514&h=514&zoom=2)

El trabajo se ha retirado del procesamiento inicial de una manera segura conocida. La publicaci√≥n puede suceder de forma as√≠ncrona a la escritura real. Esto reduce la latencia de completar la operaci√≥n inicial, tambi√©n limitar√° el n√∫mero de grabaciones de disco en el procesamiento de la solicitud inicial a uno. Esta estrategia puede ser extremadamente valiosa cuando se trata de requisitos de baja latencia ya que permite que gran parte del trabajo en el procesamiento inicial se descargue a otro proceso de forma as√≠ncrona y de manera segura, hay poca diferencia si la publicaci√≥n se realiza como parte del procesamiento inicial. o de forma as√≠ncrona, ya que, en general, los mensajes se publican de forma as√≠ncrona de todos modos, el uso de Event Store como una cola solo aumenta el tiempo hasta que el mensaje se publica ligeramente, lo que puede verse como un aumento leve del SLA.

[1]: /posts/eventos-como-mecanismo-de-almacenamiento
